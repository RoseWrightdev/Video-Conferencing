// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.1
// source: signaling.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "signaling";

/** The Master Envelope */
export interface WebSocketMessage {
  /** --- Connection & Auth --- */
  join?: JoinRequest | undefined;
  joinResponse?: JoinResponse | undefined;
  reconnect?:
    | ReconnectRequest
    | undefined;
  /** --- Media Controls (Self) --- */
  toggleMedia?: ToggleMediaRequest | undefined;
  mediaStateChanged?:
    | MediaStateEvent
    | undefined;
  /** --- Screen Share --- */
  screenShare?: ScreenShareRequest | undefined;
  screenShareChanged?:
    | ScreenShareEvent
    | undefined;
  /** Permission Flow */
  requestScreenSharePermission?: RequestScreenSharePermission | undefined;
  screenSharePermissionEvent?:
    | ScreenSharePermissionEvent
    | undefined;
  /** --- Chat --- */
  chat?: ChatRequest | undefined;
  chatEvent?:
    | ChatEvent
    | undefined;
  /** Chat History & Deletion */
  getRecentChats?: GetRecentChatsRequest | undefined;
  recentChats?: RecentChatsEvent | undefined;
  deleteChat?: DeleteChatRequest | undefined;
  deleteChatEvent?:
    | DeleteChatEvent
    | undefined;
  /** --- Hand Raising --- */
  toggleHand?: ToggleHandRequest | undefined;
  handUpdate?:
    | HandUpdateEvent
    | undefined;
  /** --- Waiting Room (Host Only) --- */
  waitingRoomNotification?: WaitingRoomEvent | undefined;
  adminAction?: AdminActionRequest | undefined;
  adminEvent?:
    | AdminActionEvent
    | undefined;
  /** --- WebRTC Signaling --- */
  signal?: SignalRequest | undefined;
  signalEvent?:
    | SignalEvent
    | undefined;
  /** --- State Sync --- */
  roomState?: RoomStateEvent | undefined;
  error?: ErrorEvent | undefined;
}

/**
 * ---------------------------------------------------------
 * 1. Auth & Connection
 * ---------------------------------------------------------
 */
export interface JoinRequest {
  token: string;
  roomId: string;
  displayName: string;
}

export interface JoinResponse {
  success: boolean;
  userId: string;
  initialState: RoomStateEvent | undefined;
  isHost: boolean;
}

export interface ReconnectRequest {
  token: string;
  previousSessionId: string;
}

/**
 * ---------------------------------------------------------
 * 2. Media State (Mute/Video/Hand)
 * ---------------------------------------------------------
 */
export interface ToggleMediaRequest {
  /** "audio" or "video" */
  kind: string;
  isEnabled: boolean;
}

export interface MediaStateEvent {
  userId: string;
  isAudioEnabled: boolean;
  isVideoEnabled: boolean;
}

export interface ToggleHandRequest {
  isRaised: boolean;
}

export interface HandUpdateEvent {
  userId: string;
  isRaised: boolean;
}

/**
 * ---------------------------------------------------------
 * 3. Screen Share
 * ---------------------------------------------------------
 */
export interface ScreenShareRequest {
  isSharing: boolean;
}

export interface ScreenShareEvent {
  userId: string;
  isSharing: boolean;
}

export interface RequestScreenSharePermission {
}

export interface ScreenSharePermissionEvent {
  userId: string;
  displayName: string;
  isGranted: boolean;
}

/**
 * ---------------------------------------------------------
 * 4. Chat
 * ---------------------------------------------------------
 */
export interface ChatRequest {
  content: string;
  targetId: string;
}

export interface ChatEvent {
  id: string;
  senderId: string;
  senderName: string;
  content: string;
  timestamp: number;
  isPrivate: boolean;
}

export interface GetRecentChatsRequest {
}

export interface RecentChatsEvent {
  chats: ChatEvent[];
}

export interface DeleteChatRequest {
  chatId: string;
}

export interface DeleteChatEvent {
  chatId: string;
}

/**
 * ---------------------------------------------------------
 * 5. Admin / Waiting Room
 * ---------------------------------------------------------
 */
export interface WaitingRoomEvent {
  userId: string;
  displayName: string;
  status: string;
}

export interface AdminActionRequest {
  targetUserId: string;
  /** Actions: "approve", "reject", "kick", "mute", "unmute", "mute_all", "approve_screenshare", "reject_screenshare" */
  action: string;
}

export interface AdminActionEvent {
  action: string;
  reason: string;
}

/**
 * ---------------------------------------------------------
 * 6. WebRTC Tunnel (Forwarded to Rust)
 * ---------------------------------------------------------
 */
export interface SignalRequest {
  sdpAnswer?: string | undefined;
  iceCandidate?: string | undefined;
  renegotiate?: boolean | undefined;
}

export interface SignalEvent {
  sdpOffer?: string | undefined;
  iceCandidate?: string | undefined;
}

/**
 * ---------------------------------------------------------
 * 7. Global State
 * ---------------------------------------------------------
 */
export interface RoomStateEvent {
  participants: ParticipantInfo[];
  waitingUsers: ParticipantInfo[];
}

export interface ParticipantInfo {
  id: string;
  displayName: string;
  isHost: boolean;
  isAudioEnabled: boolean;
  isVideoEnabled: boolean;
  isScreenSharing: boolean;
  isHandRaised: boolean;
}

export interface ErrorEvent {
  code: string;
  message: string;
  fatal: boolean;
}

function createBaseWebSocketMessage(): WebSocketMessage {
  return {
    join: undefined,
    joinResponse: undefined,
    reconnect: undefined,
    toggleMedia: undefined,
    mediaStateChanged: undefined,
    screenShare: undefined,
    screenShareChanged: undefined,
    requestScreenSharePermission: undefined,
    screenSharePermissionEvent: undefined,
    chat: undefined,
    chatEvent: undefined,
    getRecentChats: undefined,
    recentChats: undefined,
    deleteChat: undefined,
    deleteChatEvent: undefined,
    toggleHand: undefined,
    handUpdate: undefined,
    waitingRoomNotification: undefined,
    adminAction: undefined,
    adminEvent: undefined,
    signal: undefined,
    signalEvent: undefined,
    roomState: undefined,
    error: undefined,
  };
}

export const WebSocketMessage: MessageFns<WebSocketMessage> = {
  encode(message: WebSocketMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.join !== undefined) {
      JoinRequest.encode(message.join, writer.uint32(10).fork()).join();
    }
    if (message.joinResponse !== undefined) {
      JoinResponse.encode(message.joinResponse, writer.uint32(18).fork()).join();
    }
    if (message.reconnect !== undefined) {
      ReconnectRequest.encode(message.reconnect, writer.uint32(26).fork()).join();
    }
    if (message.toggleMedia !== undefined) {
      ToggleMediaRequest.encode(message.toggleMedia, writer.uint32(34).fork()).join();
    }
    if (message.mediaStateChanged !== undefined) {
      MediaStateEvent.encode(message.mediaStateChanged, writer.uint32(42).fork()).join();
    }
    if (message.screenShare !== undefined) {
      ScreenShareRequest.encode(message.screenShare, writer.uint32(50).fork()).join();
    }
    if (message.screenShareChanged !== undefined) {
      ScreenShareEvent.encode(message.screenShareChanged, writer.uint32(58).fork()).join();
    }
    if (message.requestScreenSharePermission !== undefined) {
      RequestScreenSharePermission.encode(message.requestScreenSharePermission, writer.uint32(162).fork()).join();
    }
    if (message.screenSharePermissionEvent !== undefined) {
      ScreenSharePermissionEvent.encode(message.screenSharePermissionEvent, writer.uint32(170).fork()).join();
    }
    if (message.chat !== undefined) {
      ChatRequest.encode(message.chat, writer.uint32(66).fork()).join();
    }
    if (message.chatEvent !== undefined) {
      ChatEvent.encode(message.chatEvent, writer.uint32(74).fork()).join();
    }
    if (message.getRecentChats !== undefined) {
      GetRecentChatsRequest.encode(message.getRecentChats, writer.uint32(178).fork()).join();
    }
    if (message.recentChats !== undefined) {
      RecentChatsEvent.encode(message.recentChats, writer.uint32(186).fork()).join();
    }
    if (message.deleteChat !== undefined) {
      DeleteChatRequest.encode(message.deleteChat, writer.uint32(194).fork()).join();
    }
    if (message.deleteChatEvent !== undefined) {
      DeleteChatEvent.encode(message.deleteChatEvent, writer.uint32(202).fork()).join();
    }
    if (message.toggleHand !== undefined) {
      ToggleHandRequest.encode(message.toggleHand, writer.uint32(82).fork()).join();
    }
    if (message.handUpdate !== undefined) {
      HandUpdateEvent.encode(message.handUpdate, writer.uint32(90).fork()).join();
    }
    if (message.waitingRoomNotification !== undefined) {
      WaitingRoomEvent.encode(message.waitingRoomNotification, writer.uint32(98).fork()).join();
    }
    if (message.adminAction !== undefined) {
      AdminActionRequest.encode(message.adminAction, writer.uint32(106).fork()).join();
    }
    if (message.adminEvent !== undefined) {
      AdminActionEvent.encode(message.adminEvent, writer.uint32(114).fork()).join();
    }
    if (message.signal !== undefined) {
      SignalRequest.encode(message.signal, writer.uint32(122).fork()).join();
    }
    if (message.signalEvent !== undefined) {
      SignalEvent.encode(message.signalEvent, writer.uint32(130).fork()).join();
    }
    if (message.roomState !== undefined) {
      RoomStateEvent.encode(message.roomState, writer.uint32(138).fork()).join();
    }
    if (message.error !== undefined) {
      ErrorEvent.encode(message.error, writer.uint32(146).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebSocketMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebSocketMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.join = JoinRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.joinResponse = JoinResponse.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reconnect = ReconnectRequest.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toggleMedia = ToggleMediaRequest.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.mediaStateChanged = MediaStateEvent.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.screenShare = ScreenShareRequest.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.screenShareChanged = ScreenShareEvent.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.requestScreenSharePermission = RequestScreenSharePermission.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.screenSharePermissionEvent = ScreenSharePermissionEvent.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.chat = ChatRequest.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.chatEvent = ChatEvent.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.getRecentChats = GetRecentChatsRequest.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.recentChats = RecentChatsEvent.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.deleteChat = DeleteChatRequest.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.deleteChatEvent = DeleteChatEvent.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.toggleHand = ToggleHandRequest.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.handUpdate = HandUpdateEvent.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.waitingRoomNotification = WaitingRoomEvent.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.adminAction = AdminActionRequest.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.adminEvent = AdminActionEvent.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.signal = SignalRequest.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.signalEvent = SignalEvent.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.roomState = RoomStateEvent.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.error = ErrorEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<WebSocketMessage>, I>>(base?: I): WebSocketMessage {
    return WebSocketMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebSocketMessage>, I>>(object: I): WebSocketMessage {
    const message = createBaseWebSocketMessage();
    message.join = (object.join !== undefined && object.join !== null)
      ? JoinRequest.fromPartial(object.join)
      : undefined;
    message.joinResponse = (object.joinResponse !== undefined && object.joinResponse !== null)
      ? JoinResponse.fromPartial(object.joinResponse)
      : undefined;
    message.reconnect = (object.reconnect !== undefined && object.reconnect !== null)
      ? ReconnectRequest.fromPartial(object.reconnect)
      : undefined;
    message.toggleMedia = (object.toggleMedia !== undefined && object.toggleMedia !== null)
      ? ToggleMediaRequest.fromPartial(object.toggleMedia)
      : undefined;
    message.mediaStateChanged = (object.mediaStateChanged !== undefined && object.mediaStateChanged !== null)
      ? MediaStateEvent.fromPartial(object.mediaStateChanged)
      : undefined;
    message.screenShare = (object.screenShare !== undefined && object.screenShare !== null)
      ? ScreenShareRequest.fromPartial(object.screenShare)
      : undefined;
    message.screenShareChanged = (object.screenShareChanged !== undefined && object.screenShareChanged !== null)
      ? ScreenShareEvent.fromPartial(object.screenShareChanged)
      : undefined;
    message.requestScreenSharePermission =
      (object.requestScreenSharePermission !== undefined && object.requestScreenSharePermission !== null)
        ? RequestScreenSharePermission.fromPartial(object.requestScreenSharePermission)
        : undefined;
    message.screenSharePermissionEvent =
      (object.screenSharePermissionEvent !== undefined && object.screenSharePermissionEvent !== null)
        ? ScreenSharePermissionEvent.fromPartial(object.screenSharePermissionEvent)
        : undefined;
    message.chat = (object.chat !== undefined && object.chat !== null)
      ? ChatRequest.fromPartial(object.chat)
      : undefined;
    message.chatEvent = (object.chatEvent !== undefined && object.chatEvent !== null)
      ? ChatEvent.fromPartial(object.chatEvent)
      : undefined;
    message.getRecentChats = (object.getRecentChats !== undefined && object.getRecentChats !== null)
      ? GetRecentChatsRequest.fromPartial(object.getRecentChats)
      : undefined;
    message.recentChats = (object.recentChats !== undefined && object.recentChats !== null)
      ? RecentChatsEvent.fromPartial(object.recentChats)
      : undefined;
    message.deleteChat = (object.deleteChat !== undefined && object.deleteChat !== null)
      ? DeleteChatRequest.fromPartial(object.deleteChat)
      : undefined;
    message.deleteChatEvent = (object.deleteChatEvent !== undefined && object.deleteChatEvent !== null)
      ? DeleteChatEvent.fromPartial(object.deleteChatEvent)
      : undefined;
    message.toggleHand = (object.toggleHand !== undefined && object.toggleHand !== null)
      ? ToggleHandRequest.fromPartial(object.toggleHand)
      : undefined;
    message.handUpdate = (object.handUpdate !== undefined && object.handUpdate !== null)
      ? HandUpdateEvent.fromPartial(object.handUpdate)
      : undefined;
    message.waitingRoomNotification =
      (object.waitingRoomNotification !== undefined && object.waitingRoomNotification !== null)
        ? WaitingRoomEvent.fromPartial(object.waitingRoomNotification)
        : undefined;
    message.adminAction = (object.adminAction !== undefined && object.adminAction !== null)
      ? AdminActionRequest.fromPartial(object.adminAction)
      : undefined;
    message.adminEvent = (object.adminEvent !== undefined && object.adminEvent !== null)
      ? AdminActionEvent.fromPartial(object.adminEvent)
      : undefined;
    message.signal = (object.signal !== undefined && object.signal !== null)
      ? SignalRequest.fromPartial(object.signal)
      : undefined;
    message.signalEvent = (object.signalEvent !== undefined && object.signalEvent !== null)
      ? SignalEvent.fromPartial(object.signalEvent)
      : undefined;
    message.roomState = (object.roomState !== undefined && object.roomState !== null)
      ? RoomStateEvent.fromPartial(object.roomState)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? ErrorEvent.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseJoinRequest(): JoinRequest {
  return { token: "", roomId: "", displayName: "" };
}

export const JoinRequest: MessageFns<JoinRequest> = {
  encode(message: JoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.roomId !== "") {
      writer.uint32(18).string(message.roomId);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<JoinRequest>, I>>(base?: I): JoinRequest {
    return JoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JoinRequest>, I>>(object: I): JoinRequest {
    const message = createBaseJoinRequest();
    message.token = object.token ?? "";
    message.roomId = object.roomId ?? "";
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseJoinResponse(): JoinResponse {
  return { success: false, userId: "", initialState: undefined, isHost: false };
}

export const JoinResponse: MessageFns<JoinResponse> = {
  encode(message: JoinResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.initialState !== undefined) {
      RoomStateEvent.encode(message.initialState, writer.uint32(26).fork()).join();
    }
    if (message.isHost !== false) {
      writer.uint32(32).bool(message.isHost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.initialState = RoomStateEvent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isHost = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<JoinResponse>, I>>(base?: I): JoinResponse {
    return JoinResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JoinResponse>, I>>(object: I): JoinResponse {
    const message = createBaseJoinResponse();
    message.success = object.success ?? false;
    message.userId = object.userId ?? "";
    message.initialState = (object.initialState !== undefined && object.initialState !== null)
      ? RoomStateEvent.fromPartial(object.initialState)
      : undefined;
    message.isHost = object.isHost ?? false;
    return message;
  },
};

function createBaseReconnectRequest(): ReconnectRequest {
  return { token: "", previousSessionId: "" };
}

export const ReconnectRequest: MessageFns<ReconnectRequest> = {
  encode(message: ReconnectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.previousSessionId !== "") {
      writer.uint32(18).string(message.previousSessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReconnectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReconnectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.previousSessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ReconnectRequest>, I>>(base?: I): ReconnectRequest {
    return ReconnectRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReconnectRequest>, I>>(object: I): ReconnectRequest {
    const message = createBaseReconnectRequest();
    message.token = object.token ?? "";
    message.previousSessionId = object.previousSessionId ?? "";
    return message;
  },
};

function createBaseToggleMediaRequest(): ToggleMediaRequest {
  return { kind: "", isEnabled: false };
}

export const ToggleMediaRequest: MessageFns<ToggleMediaRequest> = {
  encode(message: ToggleMediaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.isEnabled !== false) {
      writer.uint32(16).bool(message.isEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToggleMediaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToggleMediaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isEnabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ToggleMediaRequest>, I>>(base?: I): ToggleMediaRequest {
    return ToggleMediaRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToggleMediaRequest>, I>>(object: I): ToggleMediaRequest {
    const message = createBaseToggleMediaRequest();
    message.kind = object.kind ?? "";
    message.isEnabled = object.isEnabled ?? false;
    return message;
  },
};

function createBaseMediaStateEvent(): MediaStateEvent {
  return { userId: "", isAudioEnabled: false, isVideoEnabled: false };
}

export const MediaStateEvent: MessageFns<MediaStateEvent> = {
  encode(message: MediaStateEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.isAudioEnabled !== false) {
      writer.uint32(16).bool(message.isAudioEnabled);
    }
    if (message.isVideoEnabled !== false) {
      writer.uint32(24).bool(message.isVideoEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MediaStateEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMediaStateEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isAudioEnabled = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isVideoEnabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<MediaStateEvent>, I>>(base?: I): MediaStateEvent {
    return MediaStateEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MediaStateEvent>, I>>(object: I): MediaStateEvent {
    const message = createBaseMediaStateEvent();
    message.userId = object.userId ?? "";
    message.isAudioEnabled = object.isAudioEnabled ?? false;
    message.isVideoEnabled = object.isVideoEnabled ?? false;
    return message;
  },
};

function createBaseToggleHandRequest(): ToggleHandRequest {
  return { isRaised: false };
}

export const ToggleHandRequest: MessageFns<ToggleHandRequest> = {
  encode(message: ToggleHandRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isRaised !== false) {
      writer.uint32(8).bool(message.isRaised);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToggleHandRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToggleHandRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isRaised = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ToggleHandRequest>, I>>(base?: I): ToggleHandRequest {
    return ToggleHandRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToggleHandRequest>, I>>(object: I): ToggleHandRequest {
    const message = createBaseToggleHandRequest();
    message.isRaised = object.isRaised ?? false;
    return message;
  },
};

function createBaseHandUpdateEvent(): HandUpdateEvent {
  return { userId: "", isRaised: false };
}

export const HandUpdateEvent: MessageFns<HandUpdateEvent> = {
  encode(message: HandUpdateEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.isRaised !== false) {
      writer.uint32(16).bool(message.isRaised);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandUpdateEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandUpdateEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isRaised = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<HandUpdateEvent>, I>>(base?: I): HandUpdateEvent {
    return HandUpdateEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HandUpdateEvent>, I>>(object: I): HandUpdateEvent {
    const message = createBaseHandUpdateEvent();
    message.userId = object.userId ?? "";
    message.isRaised = object.isRaised ?? false;
    return message;
  },
};

function createBaseScreenShareRequest(): ScreenShareRequest {
  return { isSharing: false };
}

export const ScreenShareRequest: MessageFns<ScreenShareRequest> = {
  encode(message: ScreenShareRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isSharing !== false) {
      writer.uint32(8).bool(message.isSharing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScreenShareRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScreenShareRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isSharing = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ScreenShareRequest>, I>>(base?: I): ScreenShareRequest {
    return ScreenShareRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScreenShareRequest>, I>>(object: I): ScreenShareRequest {
    const message = createBaseScreenShareRequest();
    message.isSharing = object.isSharing ?? false;
    return message;
  },
};

function createBaseScreenShareEvent(): ScreenShareEvent {
  return { userId: "", isSharing: false };
}

export const ScreenShareEvent: MessageFns<ScreenShareEvent> = {
  encode(message: ScreenShareEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.isSharing !== false) {
      writer.uint32(16).bool(message.isSharing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScreenShareEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScreenShareEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSharing = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ScreenShareEvent>, I>>(base?: I): ScreenShareEvent {
    return ScreenShareEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScreenShareEvent>, I>>(object: I): ScreenShareEvent {
    const message = createBaseScreenShareEvent();
    message.userId = object.userId ?? "";
    message.isSharing = object.isSharing ?? false;
    return message;
  },
};

function createBaseRequestScreenSharePermission(): RequestScreenSharePermission {
  return {};
}

export const RequestScreenSharePermission: MessageFns<RequestScreenSharePermission> = {
  encode(_: RequestScreenSharePermission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestScreenSharePermission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestScreenSharePermission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RequestScreenSharePermission>, I>>(base?: I): RequestScreenSharePermission {
    return RequestScreenSharePermission.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestScreenSharePermission>, I>>(_: I): RequestScreenSharePermission {
    const message = createBaseRequestScreenSharePermission();
    return message;
  },
};

function createBaseScreenSharePermissionEvent(): ScreenSharePermissionEvent {
  return { userId: "", displayName: "", isGranted: false };
}

export const ScreenSharePermissionEvent: MessageFns<ScreenSharePermissionEvent> = {
  encode(message: ScreenSharePermissionEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.isGranted !== false) {
      writer.uint32(24).bool(message.isGranted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScreenSharePermissionEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScreenSharePermissionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isGranted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ScreenSharePermissionEvent>, I>>(base?: I): ScreenSharePermissionEvent {
    return ScreenSharePermissionEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScreenSharePermissionEvent>, I>>(object: I): ScreenSharePermissionEvent {
    const message = createBaseScreenSharePermissionEvent();
    message.userId = object.userId ?? "";
    message.displayName = object.displayName ?? "";
    message.isGranted = object.isGranted ?? false;
    return message;
  },
};

function createBaseChatRequest(): ChatRequest {
  return { content: "", targetId: "" };
}

export const ChatRequest: MessageFns<ChatRequest> = {
  encode(message: ChatRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    if (message.targetId !== "") {
      writer.uint32(18).string(message.targetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ChatRequest>, I>>(base?: I): ChatRequest {
    return ChatRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatRequest>, I>>(object: I): ChatRequest {
    const message = createBaseChatRequest();
    message.content = object.content ?? "";
    message.targetId = object.targetId ?? "";
    return message;
  },
};

function createBaseChatEvent(): ChatEvent {
  return { id: "", senderId: "", senderName: "", content: "", timestamp: 0, isPrivate: false };
}

export const ChatEvent: MessageFns<ChatEvent> = {
  encode(message: ChatEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.senderId !== "") {
      writer.uint32(18).string(message.senderId);
    }
    if (message.senderName !== "") {
      writer.uint32(26).string(message.senderName);
    }
    if (message.content !== "") {
      writer.uint32(34).string(message.content);
    }
    if (message.timestamp !== 0) {
      writer.uint32(40).int64(message.timestamp);
    }
    if (message.isPrivate !== false) {
      writer.uint32(48).bool(message.isPrivate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.senderId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.senderName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isPrivate = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ChatEvent>, I>>(base?: I): ChatEvent {
    return ChatEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatEvent>, I>>(object: I): ChatEvent {
    const message = createBaseChatEvent();
    message.id = object.id ?? "";
    message.senderId = object.senderId ?? "";
    message.senderName = object.senderName ?? "";
    message.content = object.content ?? "";
    message.timestamp = object.timestamp ?? 0;
    message.isPrivate = object.isPrivate ?? false;
    return message;
  },
};

function createBaseGetRecentChatsRequest(): GetRecentChatsRequest {
  return {};
}

export const GetRecentChatsRequest: MessageFns<GetRecentChatsRequest> = {
  encode(_: GetRecentChatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRecentChatsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRecentChatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<GetRecentChatsRequest>, I>>(base?: I): GetRecentChatsRequest {
    return GetRecentChatsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRecentChatsRequest>, I>>(_: I): GetRecentChatsRequest {
    const message = createBaseGetRecentChatsRequest();
    return message;
  },
};

function createBaseRecentChatsEvent(): RecentChatsEvent {
  return { chats: [] };
}

export const RecentChatsEvent: MessageFns<RecentChatsEvent> = {
  encode(message: RecentChatsEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.chats) {
      ChatEvent.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecentChatsEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecentChatsEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chats.push(ChatEvent.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RecentChatsEvent>, I>>(base?: I): RecentChatsEvent {
    return RecentChatsEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RecentChatsEvent>, I>>(object: I): RecentChatsEvent {
    const message = createBaseRecentChatsEvent();
    message.chats = object.chats?.map((e) => ChatEvent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteChatRequest(): DeleteChatRequest {
  return { chatId: "" };
}

export const DeleteChatRequest: MessageFns<DeleteChatRequest> = {
  encode(message: DeleteChatRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chatId !== "") {
      writer.uint32(10).string(message.chatId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteChatRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteChatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<DeleteChatRequest>, I>>(base?: I): DeleteChatRequest {
    return DeleteChatRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteChatRequest>, I>>(object: I): DeleteChatRequest {
    const message = createBaseDeleteChatRequest();
    message.chatId = object.chatId ?? "";
    return message;
  },
};

function createBaseDeleteChatEvent(): DeleteChatEvent {
  return { chatId: "" };
}

export const DeleteChatEvent: MessageFns<DeleteChatEvent> = {
  encode(message: DeleteChatEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chatId !== "") {
      writer.uint32(10).string(message.chatId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteChatEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteChatEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<DeleteChatEvent>, I>>(base?: I): DeleteChatEvent {
    return DeleteChatEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteChatEvent>, I>>(object: I): DeleteChatEvent {
    const message = createBaseDeleteChatEvent();
    message.chatId = object.chatId ?? "";
    return message;
  },
};

function createBaseWaitingRoomEvent(): WaitingRoomEvent {
  return { userId: "", displayName: "", status: "" };
}

export const WaitingRoomEvent: MessageFns<WaitingRoomEvent> = {
  encode(message: WaitingRoomEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WaitingRoomEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaitingRoomEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<WaitingRoomEvent>, I>>(base?: I): WaitingRoomEvent {
    return WaitingRoomEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WaitingRoomEvent>, I>>(object: I): WaitingRoomEvent {
    const message = createBaseWaitingRoomEvent();
    message.userId = object.userId ?? "";
    message.displayName = object.displayName ?? "";
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseAdminActionRequest(): AdminActionRequest {
  return { targetUserId: "", action: "" };
}

export const AdminActionRequest: MessageFns<AdminActionRequest> = {
  encode(message: AdminActionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetUserId !== "") {
      writer.uint32(10).string(message.targetUserId);
    }
    if (message.action !== "") {
      writer.uint32(18).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminActionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.targetUserId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<AdminActionRequest>, I>>(base?: I): AdminActionRequest {
    return AdminActionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminActionRequest>, I>>(object: I): AdminActionRequest {
    const message = createBaseAdminActionRequest();
    message.targetUserId = object.targetUserId ?? "";
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseAdminActionEvent(): AdminActionEvent {
  return { action: "", reason: "" };
}

export const AdminActionEvent: MessageFns<AdminActionEvent> = {
  encode(message: AdminActionEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== "") {
      writer.uint32(10).string(message.action);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdminActionEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdminActionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<AdminActionEvent>, I>>(base?: I): AdminActionEvent {
    return AdminActionEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdminActionEvent>, I>>(object: I): AdminActionEvent {
    const message = createBaseAdminActionEvent();
    message.action = object.action ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseSignalRequest(): SignalRequest {
  return { sdpAnswer: undefined, iceCandidate: undefined, renegotiate: undefined };
}

export const SignalRequest: MessageFns<SignalRequest> = {
  encode(message: SignalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sdpAnswer !== undefined) {
      writer.uint32(10).string(message.sdpAnswer);
    }
    if (message.iceCandidate !== undefined) {
      writer.uint32(18).string(message.iceCandidate);
    }
    if (message.renegotiate !== undefined) {
      writer.uint32(24).bool(message.renegotiate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sdpAnswer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.iceCandidate = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.renegotiate = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<SignalRequest>, I>>(base?: I): SignalRequest {
    return SignalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignalRequest>, I>>(object: I): SignalRequest {
    const message = createBaseSignalRequest();
    message.sdpAnswer = object.sdpAnswer ?? undefined;
    message.iceCandidate = object.iceCandidate ?? undefined;
    message.renegotiate = object.renegotiate ?? undefined;
    return message;
  },
};

function createBaseSignalEvent(): SignalEvent {
  return { sdpOffer: undefined, iceCandidate: undefined };
}

export const SignalEvent: MessageFns<SignalEvent> = {
  encode(message: SignalEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sdpOffer !== undefined) {
      writer.uint32(10).string(message.sdpOffer);
    }
    if (message.iceCandidate !== undefined) {
      writer.uint32(18).string(message.iceCandidate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignalEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignalEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sdpOffer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.iceCandidate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<SignalEvent>, I>>(base?: I): SignalEvent {
    return SignalEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignalEvent>, I>>(object: I): SignalEvent {
    const message = createBaseSignalEvent();
    message.sdpOffer = object.sdpOffer ?? undefined;
    message.iceCandidate = object.iceCandidate ?? undefined;
    return message;
  },
};

function createBaseRoomStateEvent(): RoomStateEvent {
  return { participants: [], waitingUsers: [] };
}

export const RoomStateEvent: MessageFns<RoomStateEvent> = {
  encode(message: RoomStateEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.participants) {
      ParticipantInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.waitingUsers) {
      ParticipantInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoomStateEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoomStateEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.participants.push(ParticipantInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.waitingUsers.push(ParticipantInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RoomStateEvent>, I>>(base?: I): RoomStateEvent {
    return RoomStateEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoomStateEvent>, I>>(object: I): RoomStateEvent {
    const message = createBaseRoomStateEvent();
    message.participants = object.participants?.map((e) => ParticipantInfo.fromPartial(e)) || [];
    message.waitingUsers = object.waitingUsers?.map((e) => ParticipantInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseParticipantInfo(): ParticipantInfo {
  return {
    id: "",
    displayName: "",
    isHost: false,
    isAudioEnabled: false,
    isVideoEnabled: false,
    isScreenSharing: false,
    isHandRaised: false,
  };
}

export const ParticipantInfo: MessageFns<ParticipantInfo> = {
  encode(message: ParticipantInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.isHost !== false) {
      writer.uint32(24).bool(message.isHost);
    }
    if (message.isAudioEnabled !== false) {
      writer.uint32(32).bool(message.isAudioEnabled);
    }
    if (message.isVideoEnabled !== false) {
      writer.uint32(40).bool(message.isVideoEnabled);
    }
    if (message.isScreenSharing !== false) {
      writer.uint32(48).bool(message.isScreenSharing);
    }
    if (message.isHandRaised !== false) {
      writer.uint32(56).bool(message.isHandRaised);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParticipantInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParticipantInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isHost = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isAudioEnabled = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isVideoEnabled = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isScreenSharing = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isHandRaised = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ParticipantInfo>, I>>(base?: I): ParticipantInfo {
    return ParticipantInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParticipantInfo>, I>>(object: I): ParticipantInfo {
    const message = createBaseParticipantInfo();
    message.id = object.id ?? "";
    message.displayName = object.displayName ?? "";
    message.isHost = object.isHost ?? false;
    message.isAudioEnabled = object.isAudioEnabled ?? false;
    message.isVideoEnabled = object.isVideoEnabled ?? false;
    message.isScreenSharing = object.isScreenSharing ?? false;
    message.isHandRaised = object.isHandRaised ?? false;
    return message;
  },
};

function createBaseErrorEvent(): ErrorEvent {
  return { code: "", message: "", fatal: false };
}

export const ErrorEvent: MessageFns<ErrorEvent> = {
  encode(message: ErrorEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.fatal !== false) {
      writer.uint32(24).bool(message.fatal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fatal = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ErrorEvent>, I>>(base?: I): ErrorEvent {
    return ErrorEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorEvent>, I>>(object: I): ErrorEvent {
    const message = createBaseErrorEvent();
    message.code = object.code ?? "";
    message.message = object.message ?? "";
    message.fatal = object.fatal ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
